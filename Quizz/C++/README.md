## Q: VS2005点击运行按钮后发生了什么

经过预处理, 编译, 汇编, 链接等多个步骤, 才能生成可以再机器上直接运行的可执行程序.

![](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=4167137638,3334516333&fm=173&app=25&f=JPEG?w=637&h=100)

- 编译器对预处理的代码进行词法分析, 语法分析, 语义分析, 将符合规则的程序转换成等价的汇编代码.
- 汇编器将编译生成的汇编代码翻译成计算机可以识别的机器指令, 并生成目标文件. 之所以不讲源程序直接生成机器指令是因为在不同的阶段可以应用不同的优化技术, 并且技术都已经非常成熟, 可以保证在每个阶段分别进行优化后最终生成可以更为高效的机器指令
- 链接器将所有目标程序链接在一起, 无论是静态链接还是动态链接, 最终都会生成一个可以在机器上直接执行的可运行程序.

## Q: 预处理做了什么工作

所有以#开头的代码都属于预处理器处理的范畴

1. #include: 将头文件的内容包含到源文件中
2. #define: 将宏定义进行宏展开
3. #ifdef: 条件编译展开(#ifdef, #ifndef, #if, #else, #elif, #endif)
4. #other: 处理其它宏指令(包括#error, #warning, #line, #pragma)

实际上除了处理#开头的代码行以外, 还做了一些其他工作, 只是提到预处理时, 习惯性的把它的功能与处理#开头的代码划上等号.

1. 处理预定义的宏, 例如 _ _ DATE_ _  , _ _ FILE _ _(这种宏都是以双下划线开始, 并结束, 自己写宏的时候应该避免冲突)
2. 处理注释
3. 处理三元符??=替换成#, ??/替换成\ (这种是因为在最早的C语言中, 键盘输入不全, 有些键盘无法输入#等, 现在则没有)

## Q: 简述#include<> 和#include ""的区别

这两种都可以将指定文件中的内容引入到当前文件, 但采用了不同的搜索策略, #include<>搜索时直接从编译器指定的路径进行搜索, 如果找不到引入文件, 程序直接报错, 因此系统提供的头文件推荐使用#include<>. #include""首先从程序所在的目录进行搜索, 如果失败再从编译器指定位置进行搜索, 如果搜索失败报错. 虽然系统提供的文件也可以用#include""进行搜索导入, 但会进行无畏的搜索

## Q: 简述#与##在define中的作用

1. #在宏定义中是将后面的参数转换成字符串, 仔细观察下面两个宏的调用

```c++
#include <iostream>
using namespace std;
#define PRINTCUBE(x) cout<< "cube(" << #x <<") =" << (x) * (x) * (x) << endl;
int main() {
    int y = 5;
    PRINTCUBE(5);
    PRINTCUBE(y);
    return 0;
}
输出:
cube(5) =125
cube(y) =125
```

第一个PRINTCUBE中的5, cube中是将 5这个数字字符串化输出, 第二个是直接字符串化y.

2. ##在宏定义中是将前后的参数进行字符串连接, 而且不依赖于参数的具体类型

```c++
#define LINK3(x, y, z) x##y##z
int main() {
    cout <<LINK3(3, 5, 0)<< endl;
    return 0;
}
输出:
350
```

## Q: 简述assert断言的概念

实际上assert是一个宏, 并非一个函数, 在assert.h里定义这个宏, 检测条件表达式为假时, 检测失败. 在调试结束后应该在#include assert.h之前插入#define NDEBUG禁用assert宏.

注意事项每个assert中只检测一个条件, 另外不要再assert中修改变量的值(因为assert指在debug版本中起作用, release版本中assert内部对变量修改也随之失效, 会造成不同版本取值不同).

## Q: 简述extern, static, const三种变量的区别

全局变量是指在函数外部定义的变量

1. extern: 如果将全局变量声明在头文件中, 并使用extern关键字修饰, 起作用是将变量导出, 表示在任何通过#include包含该头文件的文件中可以使用这个全局变量
2. static: 静态变量, 如果修饰在局部称为静态局部变量, 如果修饰在全局称为静态全局变量. 静态局部变量:  局部静态变量在程序首次执行该变量处时初始化, 再次执行到该变量不会初始化, 而是保留最新值, 因此静态全局变量作用域是函数内部, 但周期是整个程序的生命周期. 静态全局变量: 使用static修饰的全局变量, 兼具静态变量和全局变量的特性.
3. const: 修饰位常量型变量, 常量变量初始化之后不可以修改. 

## Q: 简述i++和++i的区别, 并计算一段代码的值

```c++
//计算下列代码执行后i, j, m, n的值
int i = 10, j = 10;
int m = (i++) + (i++) + (i++);
int n = (++j) + (++j) + (++j);
```

i++是先赋值后加1, ++j是先加1再赋值

对于表达式m是先执行加法操作, 再执行i的自增运算.

对于表达是n是先执行所有的自增, 再执行加法操作

重点来了!

这种赋值语句依赖编译器的实现

gcc编译器中, 只要有两个完整的操作数, 就会立即执行加法运算, 所以++j在执行两次后已经具备了两个操作数, 此时j的值为12, 和第三次++j的13执行加法运算, 最终的结果是37, j的值是13

结果

```c++
vs2005下: i = 13 j = 13 m = 30 n = 39
gcc下: i = 13 j = 13 m = 30 n = 37
```

